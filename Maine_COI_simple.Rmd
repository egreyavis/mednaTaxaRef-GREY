---
title: "Maine_COI_simple"
author: "Erin Grey"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

### DEFINE THE FOLLOWING VARIABLES FOR YOUR ANALYSIS
## locus choices are: 
## (GENES) "ATP6" "ATP8"  "COI"  "COII"  "COIII"  "CYTB"  "ND1"  "ND2"  "ND3"  "ND4" "ND4L" "ND5"  "ND6"  
## (OTHER FEATURES) "rRNA_12S" "rRNA_16S" "D_loop" "tRNA_Ala" "tRNA_Arg" "tRNA_Asn" "tRNA_Asp" "tRNA_Cys" "tRNA_Gln" "tRNA_Glu" "tRNA_Gly" "tRNA_His" "tRNA_Ile" "tRNA_Leu" "tRNA_Lys" "tRNA_Met" "tRNA_Phe" "tRNA_Pro" "tRNA_Ser" "tRNA_Thr" "tRNA_Trp" "tRNA_Tyr" "tRNA_Val"
## species_list must have "search_name" column that has species binomials

```{r define_variables}
entrez_key <- "7c5ac035201a1835b5a81de1b74ec8613d08" #GET YOUR OWN ENTREZ KEY AND PUT IT HERE!
locus = "COI" #name of target locus, see choices above 
output_folder <- "Maine_COI_2025-11-08" #name of your output folder every time
species_list <- read.csv("workingfiles/GNRMaineSpecies_May2024.csv") # your species list, must have column named "species" with binomial
clade_list <- read.csv("workingfiles/EukaryoteFamilies_NCBI_2023-09-19.csv") # list of eukaryote families in NCBI, change if necessary
clade_level <- "order" # what taxonomic level do you want representatives for, 
max_species_per_clade = 3 # how many representative species per missing clade? must be numeric

#species_list <- species_list[c(205:215, 12796, 639, 8902,9775),] ## SUBSET FOR TESTING
#clade_list <- clade_list[sample(nrow(clade_list), 10, replace=FALSE),] ## SUBSET FOR TESTING
```

### LOAD PACKAGES ETC.
```{r loadPackagesAndTerms}
source("functions.R") #use these in-house functions in this R script
library(rentrez) #queries ENTREZ databases and downloads accessions
library(AnnotationBustR) #list of locus synonyms
library(reutils) #other packages need it
library(ape) #convert fasta, fastq, etc.
library(ggplot2) #plots
library(data.table) #faster processing
library(Biostrings) #sequence manipulations

set_entrez_key(entrez_key) #set the Entrez API key

dir.create(output_folder) #create the output folder

# Get the locus search term
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
mtDNAterms <- rbind(mtDNAterms, data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA")) # adding other synonyms I've found
is_mtgene <- locus %in% c("ATP6","ATP8","COI","COII","COIII","CYTB","ND1","ND2","ND3","ND4","ND4L","ND5","ND6") #is locus a gene? needed for scraping
locus_synonyms <- mtDNAterms[mtDNAterms$Locus==locus,] #the target locus synonyms
locus_synonyms$Terms <- paste0("OR ", locus_synonyms$Name, "[TITL]") # format for ENTREZ search terms
locus_synonyms$Terms[1] <- paste0("AND (", locus_synonyms$Name[1], "[TITL]") # first term starts with "AND ("
locus_synonyms$Terms[dim(locus_synonyms)[1]] <- paste0("OR ", locus_synonyms$Name[dim(locus_synonyms)[1]], "[TITL])") #last term ends with a ")"
locus_searchterm <- paste(as.vector(locus_synonyms$Terms), collapse=" ") # the big ENTREZ locus search term
print(locus_searchterm)

# Add the taxonomy ids to the names
tax_df <- add_taxids_to_taxonomy(species_list)
tax_df <- tax_df[,c("superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species")]
tax_df <- tax_df[tax_df$species != "na",] # remove any taxa without species names
tax_df <- backfill_missing_ranks(tax_df)
head(tax_df) # check format
```

### IDENTFY MISSING CLADES
```{r getTaxonomiesAndMissingClades}

clades_tax_df <- unique(tax_df[[clade_level]]) 
setDT(clade_list)
clade_uniques <- clade_list[!duplicated(clade_list[, ..clade_level]),] # deduplicate the clade of interest in the list
clades_missing <- clade_uniques[!(get(clade_level) %in% clades_tax_df), .(superkingdom, kingdom, phylum, class, order)] #clades not represented in the tax_df
clades_missing$spp_list <- NA

```

### GET SPECIES REPRESENTATIVES FOR MISSNG CLADES
```{r getMissingCladeSpecies_optional}

clade_seqs <- process_missing_clades(
  clades_missing = clades_missing,
  locus_searchterm = locus_searchterm,
  rank_column = clade_level,
  max_species_per_clade = max_species_per_clade
  )

```

### SEARCH ENTREZ FOR ACCESSIONS BY SPECIES AND LOCUS
```{r search_species_accessions}
setDT(tax_df) # Convert to data.table for faster processing

# Process all species and update data.table by reference
cat("Searching GenBank for", nrow(tax_df), "species\n")

results_list <- lapply(1:nrow(tax_df), function(i) {
  cat("\rFinding GenBank accessions & mitogenomes for species", i, "of", nrow(tax_df))
  
  search_species_accessions(
    species_row = tax_df[i, ],
    locus_searchterm = locus_searchterm,
    delay = 0.35
  )
})

cat("\n")

# Convert results_list to data.frame
results_df <- rbindlist(lapply(results_list, function(x) {
  data.frame(
    n_mitogenome = x$n_mitogenome,
    ids_mitogenome = x$ids_mitogenome,
    n_target = x$n_target,
    ids_target = x$ids_target,
    stringsAsFactors = FALSE
  )
}), fill = TRUE)

# Add the search results to tax_df
tax_df$n_mitogenome <- results_df$n_mitogenome
tax_df$ids_mitogenome <- results_df$ids_mitogenome
tax_df$n_target <- results_df$n_target
tax_df$ids_target <- results_df$ids_target

# Now combine with clade_seqs
setDT(tax_df)
setDT(clade_seqs)

# Make sure both have the same columns
tax_df <- rbind(tax_df, clade_seqs, fill = TRUE)

# Save results
fwrite(tax_df, file.path(output_folder, paste0("tax_accessions_", locus, "_", Sys.Date(),".csv")))

cat("Complete! Saved results to tax_accessions.csv\n")

```

### GET ACCESSIONS
```{r fetch_accessions}
cat("Fetch accessions for", nrow(tax_df), "species\n")

results_list <- lapply(1:nrow(tax_df), function(i) {
  cat("\rFetching accessions for species", i, "of", nrow(tax_df))
  
  result <- tryCatch({
    fetch_species_accessions(
      species_row = tax_df[i, ],
      locus = locus,
      output_folder = output_folder,
      max_seqs = 100
    )
  }, error = function(e) {
    warning(paste("Error processing species", i, ":", e$message))
    return(NULL)
  })
  
  Sys.sleep(1)
  
  return(result)
})

cat("\n")

# Combine all results, removing NULLs
results_list <- results_list[!sapply(results_list, is.null)]

if (length(results_list) == 0) {
  warning("No sequences fetched for any species")
  REFDB <- data.frame()
} else {
  REFDB <- do.call(rbind, results_list)
  row.names(REFDB) <- NULL
  cat("Complete! Fetched", nrow(REFDB), "sequences\n")
}

```

### GET TARGET LOCI FROM MITOGENOMES
```{r scrape_mitogenomes}
setDT(tax_df) # Convert to data.table for faster operations

REFDB_scrapes <- rbindlist(lapply(1:nrow(tax_df), function(i) {
  cat("\rSpecies", i, "of", nrow(tax_df))
  
  process_species_mitogenomes(
    as.list(tax_df[i, ]), 
    target_synonyms = locus_synonyms$Name,
    is_gene = is_mtgene,
    max_mitos = 20
  )
}), fill = TRUE)

REFDB_scrapes <- REFDB_scrapes[!is.na(sequence)] # Remove rows with NA sequences
cat("\nComplete! Processed", nrow(REFDB_scrapes), "sequences\n")

REFDB_all <- rbind(REFDB_accessions, REFDB_scrapes)
REFDB_all <- merge(REFDB_all, tax_df[,c("superkingdom","kingdom","phylum","class","order","family","genus","species")], by="species", all.x=TRUE)
```

## De-duplicate the reference database, but keep track of duplicates in original species_list
```{r remove_duplicates}

setDT(REFDB_all) # Convert to data.table
REFDB_unique <- REFDB_all[!duplicated(sequence)] # Remove duplicates while keeping first occurrence

# Aggregate duplicates - MUCH faster than looping
duplicate_summary <- REFDB_all[, .(
  duplicate_accessions = paste(seq_accession, collapse = "|"),
  duplicate_species = paste(unique(species), collapse = "|")
), by = sequence]

# Merge back to unique sequences
REFDB_unique <- merge(
  REFDB_unique, 
  duplicate_summary, 
  by = "sequence", 
  all.x = TRUE
)

fwrite(REFDB_unique, file.path(output_folder, paste0("REFDB_unique_", locus, "_", Sys.Date(),".csv"))) # Save results


cat("Saved", nrow(REFDB_unique), "unique sequences\n")

```

## Summarize ref sequence results for species in the original list
```{r summarize_species}

setDT(species_list)
setDT(REFDB_unique)

# Format species_list
species_list[, species_id := paste0(matched_name2, "_", taxon_id)]

# Aggregate all information from REFDB_unique in one step
agg_info <- REFDB_unique[, .(
  n_unique_seqs = .N,
  n_target = sum(type == "accession"),
  n_mitogenome = sum(type == "scrape"),
  dup_accessions = paste(unique(unlist(strsplit(paste(duplicate_accessions, collapse = "|"), "\\|"))), collapse = "|"),
  dup_species = {
    all_dup <- unlist(strsplit(paste(duplicate_species, collapse = "|"), "\\|"))
    paste(unique(all_dup), collapse = "|")
  },
  dup_species_n = {
    all_dup <- unlist(strsplit(paste(duplicate_species, collapse = "|"), "\\|"))
    length(unique(all_dup))
  }
), by = species]

# Merge with species_list
species_summary <- merge(species_list, agg_info, 
                        by.x = "species_id", by.y = "species", 
                        all.x = TRUE)

# Handle NAs
species_summary[is.na(n_unique_seqs), n_unique_seqs := 0]
species_summary[is.na(n_target), n_target := 0]
species_summary[is.na(n_mitogenome), n_mitogenome := 0]
species_summary[is.na(dup_accessions), dup_accessions := "na"]
species_summary[is.na(dup_species), dup_species := "na"]
species_summary[is.na(dup_species_n), dup_species_n := 0]

# Calculate total sequences
species_summary[, n_all_seqs := n_mitogenome + n_target]

# Summary stats
n_species_withnames <- nrow(species_summary)
n_species_withNCBInames <-  species_summary[data_source_title == "National Center for Biotechnology Information", .N]
n_species_withNCBInamesANDtargets <- species_summary[data_source_title == "National Center for Biotechnology Information" & n_all_seqs > 0, .N]
n_species_justAccessions <- species_summary[n_target > 0 & n_mitogenome == 0, .N]
n_species_justMitogenomes <- species_summary[n_target == 0 & n_mitogenome > 0, .N]
n_species_bothAccessionsAndMitogenomes <- species_summary[n_target > 0 & n_mitogenome > 0, .N]

# Save results
fwrite(species_summary, file.path(output_folder, paste0("species_list_summary_", locus, "_", Sys.Date(),".csv")))

# Print results
cat("Saved species_list_summary.csv\n")
cat("Species in the list:", n_species_withnames, "\n")
cat("Species with NCBI names:", n_species_withNCBInames, "\n")
cat("Species with NCBI names AND targets:", n_species_withNCBInamesANDtargets, "\n")
cat("Species with only Accessions:", n_species_justAccessions, "\n")
cat("Species with only Mitogenomes:", n_species_justMitogenomes, "\n")
cat("Species with Accessions & Mitogenomes:", n_species_bothAccessionsAndMitogenomes, "\n")
```

## Format REFDB for dada2 assignTaxonomy()
```{r format_dada2_optional}

REFDB_unique_dada <- merge(x=REFDB_unique, y=tax_df, by="species", all=TRUE) 
REFDB_unique_dada <- REFDB_unique_dada[!is.na(REFDB_unique_dada$sequence),]

# Create header column with ">" at the beginning
REFDB_unique_dada[, header := paste0(
  ">",
  paste(
    ifelse(is.na(kingdom.x), "", kingdom.x),
    ifelse(is.na(phylum.x), "", phylum.x),
    ifelse(is.na(class.x), "", class.x),
    ifelse(is.na(order.x), "", order.x),
    ifelse(is.na(family.x), "", family.x),
    ifelse(is.na(genus.x), "", genus.x),
    ifelse(is.na(species), "", species),
    sep = ";"
  )
)]

REFDB_unique_dada <- REFDB_unique_dada[,c("header","sequence")]
write.table(REFDB_unique_dada, file.path(output_folder, paste0("REFDB_unique_dada_", locus, "_", Sys.Date(),".fasta")), sep="\n", col.names=FALSE, row.names=FALSE, quote=FALSE)

cat("Saved dada reference library with", nrow(REFDB_unique_dada), "sequences across", length(unique(REFDB_unique_dada$header)), "species\n")
```