---
title: "Maine_COI_simple"
author: "Erin Grey"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

### DEFINE THE FOLLOWING VARIABLES FOR YOUR ANALYSIS
## locus choices are: 
## (GENES) "ATP6" "ATP8"  "COI"  "COII"  "COIII"  "CYTB"  "ND1"  "ND2"  "ND3"  "ND4" "ND4L" "ND5"  "ND6"  
## (OTHER FEATURES) "rRNA_12S" "rRNA_16S" "D_loop" "tRNA_Ala" "tRNA_Arg" "tRNA_Asn" "tRNA_Asp" "tRNA_Cys" "tRNA_Gln" "tRNA_Glu" "tRNA_Gly" "tRNA_His" "tRNA_Ile" "tRNA_Leu" "tRNA_Lys" "tRNA_Met" "tRNA_Phe" "tRNA_Pro" "tRNA_Ser" "tRNA_Thr" "tRNA_Trp" "tRNA_Tyr" "tRNA_Val"
## species_list must have "search_name" column that has species binomials

```{r define_variables}
entrez_key <- "7c5ac035201a1835b5a81de1b74ec8613d08" #GET YOUR OWN ENTREZ KEY AND PUT IT HERE!
locus = "COI" #name of target locus, see choices above 
output_folder <- "Maine_COI_2025-11-08" #name of your output folder every time
species_list <- read.csv("workingfiles/GNRMaineSpecies_May2024.csv") # your species list, must have column named "species" with binomial
clade_list <- read.csv("workingfiles/EukaryoteFamilies_NCBI_2023-09-19.csv") # list of eukaryote families in NCBI, change if necessary
clade_level <- "order" # what taxonomic level do you want representatives for, 
max_species_per_clade = 3 # how many representative species per missing clade? must be numeric

species_list <- species_list[c(205:215, 12796, 639, 8902,9775),] ## SUBSET FOR TESTING
clade_list <- clade_list[sample(nrow(clade_list), 50, replace=FALSE),] ## SUBSET FOR TESTING
```

### LOAD PACKAGES ETC.
```{r loadPackagesAndTerms}
library(rentrez) #queries ENTREZ databases and downloads accessions
library(AnnotationBustR) #list of locus synonyms
library(reutils) #other packages need it
library(ape) #convert fasta, fastq, etc.
library(ggplot2) #plots
library(data.table) #faster processing
library(Biostrings) #sequence manipulations

set_entrez_key(entrez_key) #set the Entrez API key

dir.create(output_folder) #create the output folder

source("functions.R") #use the functions in this R script

# Format clade_list to remove the _ID suffix from each taxonomy element
setDT(clade_list)
clade_tax_cols <- c("superkingdom","kingdom","phylum","class","order","family")
clade_list[, (clade_tax_cols) := lapply(.SD, function(x) sub("_.*", "", x)), .SDcols = clade_tax_cols]

data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
mtDNAterms <- rbind(mtDNAterms, data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA")) # adding other synonyms I've found
is_mtgene <- locus %in% c("ATP6","ATP8","COI","COII","COIII","CYTB","ND1","ND2","ND3","ND4","ND4L","ND5","ND6") #check whether the locus is a gene or other feature, needed for the genome scraping
locus_synonyms <- mtDNAterms[mtDNAterms$Locus==locus,] #the target locus synonyms
locus_synonyms$Terms <- paste0("OR ", locus_synonyms$Name, "[TITL]") # format for ENTREZ search terms
locus_synonyms$Terms[1] <- paste0("AND (", locus_synonyms$Name[1], "[TITL]") # first term starts with "AND ("
locus_synonyms$Terms[dim(locus_synonyms)[1]] <- paste0("OR ", locus_synonyms$Name[dim(locus_synonyms)[1]], "[TITL])") #last term ends with a ")"
locus_searchterm <- paste(as.vector(locus_synonyms$Terms), collapse=" ") # the big ENTREZ locus search term
print(locus_searchterm)
```

### GET SPECIES TAXONOMIES AND IDENTFY MISSING CLADES
```{r getTaxonomiesAndMissingClades}

tax_df <- species_list[,c("superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species", "taxon_id")]
tax_df <- tax_df[tax_df$species != "na",] # remove any taxa without species names
clades_tax_df <- unique(tax_df[,clade_level]) 

clade_uniques <- clade_list[!duplicated(clade_list[, ..clade_level]),] # deduplicate the clade of interest in the list
clade_uniques <- clade_uniques[clade_uniques$order != "character(0)",] # remove any undefined clades
clades_missing <- clade_uniques[!(get(clade_level) %in% clades_tax_df), 
                                .(superkingdom, kingdom, phylum, class, order)] #clades not represented in the tax_df
clades_missing$spp_list <- NA

```


### GET SPECIES REPRESENTATIVES FOR MISSNG CLADES
```{r getMissingCladeSpecies_optional, warnings=FALSE}

suppressWarnings({
  clade_seqs <- process_missing_clades(
  clades_missing = clades_missing,
  target_locus_searchterm = locus_searchterm,
  rank_column = clade_level,
  max_species_per_clade = max_species_per_clade
  )
})

#tax_df <- merge(tax_df, clade_seqs)

```

### SEARCH ENTREZ FOR ACCESSIONS BY SPECIES AND LOCUS
```{r search_species_accessions}
setDT(tax_df) # Convert to data.table for faster processing

# Process all species and update data.table by reference
cat("Searching GenBank for", nrow(tax_df), "species\n")

for (i in 1:nrow(tax_df)) {
  cat("\rFinding GenBank accessions & mitogenomes for species", i, "of", nrow(tax_df))
  
  result <- search_species_accessions(
    species_name = tax_df$search_name[i],
    locus_searchterm = locus_searchterm,
    delay = 0.35
  )
  
  # Update by reference (very fast with data.table)
  tax_df[i, `:=`(
    n_mitogenome = result$n_mitogenome,
    ids_mitogenome = result$ids_mitogenome,
    n_target = result$n_target,
    ids_target = result$ids_target
  )]
}

cat("\n")
colnames(clade_seqs) <- c("order","family","genus","species","taxon_id","ids_mitogenome","ids_target","n_mitogenome","n_target","tax_query")

colnames(tax_df) <- c("superkingdom","kingdom","phylum","class","order","family", "genus","species","taxon_id", "n_mitogenome", "ids_mitogenome", "n_target", "ids_target" )
fwrite(tax_df, file.path(output_folder, "tax_accessions.csv")) # Save results

cat("Complete! Saved results to tax_accessions.csv\n")

```

### GET ACCESSIONS
```{r scrape_accessions}
cat("Scraping accessions for", nrow(tax_df), "species\n")

REFDB <- rbindlist(lapply(1:nrow(tax_df), function(i) {
  cat("\rScraping accessions for species", i, "of", nrow(tax_df))
  
  result <- scrape_species_accessions(
    species_row = as.list(tax_df[i, ]),
    locus = locus,
    output_folder = output_folder,
    max_seqs = 100
  )
  
  Sys.sleep(1)
  
  return(result)
}), fill = TRUE)

cat("\nComplete! Scraped", nrow(REFDB), "sequences\n")

```

### GET TARGET LOCI FROM MITOGENOMES
```{r scrape_mitogenomes}
setDT(tax_df) # Convert to data.table for faster operations

REFDB <- rbindlist(lapply(1:nrow(tax_df), function(i) {
  cat("\rSpecies", i, "of", nrow(tax_df))
  
  process_species_mitogenomes(
    as.list(tax_df[i, ]), 
    target_synonyms = locus_synonyms,
    is_gene = is_mtgene,
    max_mitos = 20
  )
}), fill = TRUE)

REFDB <- REFDB[!is.na(sequence)] # Remove rows with NA sequences
cat("\nComplete! Processed", nrow(REFDB), "sequences\n")
```

## De-duplicate the reference database, but keep track of duplicates in original species_list
```{r remove_duplicates}

setDT(REFDB) # Convert to data.table
REFDB_unique <- REFDB[!duplicated(sequence)] # Remove duplicates while keeping first occurrence

# Aggregate duplicates - MUCH faster than looping
duplicate_summary <- REFDB[, .(
  duplicate_accessions = paste(seq_accession, collapse = "|"),
  duplicate_species = paste(unique(species), collapse = "|")
), by = sequence]

# Merge back to unique sequences
REFDB_unique <- merge(
  REFDB_unique, 
  duplicate_summary, 
  by = "sequence", 
  all.x = TRUE
)

fwrite(REFDB_unique, file.path(output_folder, "a03_UniqueRefDB.csv")) # Save results

cat("Saved", nrow(REFDB_unique), "unique sequences\n")

```

## Format REFDB for dada2 assignTaxonomy()
```{r format_dada2}
a04_UNIQUEDBdada <- merge(x=a03_UNIQUEDB, y=a01_NAMES, by.x="species", by.y="search_name", all.x=TRUE, all.y=FALSE) 
my_cols <- c("phylum", "class","order","family","genus","species.y")
a04_UNIQUEDBdada$header <- do.call(paste, c(a04_UNIQUEDBdada[my_cols], sep = ";"))
a04_UNIQUEDBdada$header2 <- paste(">",a04_UNIQUEDBdada$header, sep="")
REFDB_dada <- a04_UNIQUEDBdada[,c("header2","sequence")]
write.table(REFDB_dada, file.path(output_folder, "a04_REFDBdada.fasta"), sep="\n", col.names=FALSE, row.names=FALSE, quote=FALSE)
```


## Summarize ref sequence results for species in the original list
```{r summarize_species}
#Count reference sequences by species
counts_species <- as.data.frame(table(a03_UNIQUEDB$species)) #count the number of unique reference sequences per species
colnames(counts_species) <- c("species", "n_unique_seqs") #format
a01_NAMES <- merge(a01_NAMES, counts_species, by.x= "search_name", by.y="species", all.x=TRUE, all.y=TRUE) # update the summary database with reference sequence counts
a00_SPECIES_SUMMARY <- a01_NAMES[a01_NAMES$search_name %in% species_list$search_name,]

#add in duplicates information to BESTNAMES
a00_SPECIES_SUMMARY$dup_accessions <- "na"
a00_SPECIES_SUMMARY$dup_species <- "na"
a00_SPECIES_SUMMARY$dup_species_n <- "na"

for (b in 1:dim(a00_SPECIES_SUMMARY)[1]){
  dup_accessions <- paste(a03_UNIQUEDB[a03_UNIQUEDB$species == a00_SPECIES_SUMMARY$search_name[b], "duplicate_accessions"], collapse="|")
  dup_accessions <- unlist(strsplit(dup_accessions, split="\\|"))
  dup_accessions_unique <- paste(unique(dup_accessions), collapse="|")
  
  dup_species <- paste(a03_UNIQUEDB[a03_UNIQUEDB$species == a00_SPECIES_SUMMARY$search_name[b], "duplicate_species"], collapse="|")
  dup_species <- unlist(strsplit(dup_species, split="\\|"))
  dup_species_unique <- unique(dup_species)
  
    if (length(dup_accessions)>0){
  a00_SPECIES_SUMMARY$dup_accessions[b]<-dup_accessions_unique
  a00_SPECIES_SUMMARY$dup_species[b]<- paste(dup_species_unique, collapse="|")
  a00_SPECIES_SUMMARY$dup_species_n[b]<- length(dup_species_unique)
  }
  
  #reset variables
  rm(dup_accessions)
  rm(dup_species)
}
a00_SPECIES_SUMMARY$n_target <- as.numeric(a00_SPECIES_SUMMARY$n_target)

a00_SPECIES_SUMMARY$n_all_seqs <- a00_SPECIES_SUMMARY$n_mitogenome + a00_SPECIES_SUMMARY$n_target
n_species_withnames <- dim(a00_SPECIES_SUMMARY)[1]
n_species_withnamesANDtargets <- length(which(a00_SPECIES_SUMMARY$n_all_seqs>0))
write.csv(a00_SPECIES_SUMMARY, file.path(output_folder, "a00_SPECIES_SUMMARY.csv"), row.names=FALSE)

n_species_withnames; n_species_withnamesANDtargets
```
