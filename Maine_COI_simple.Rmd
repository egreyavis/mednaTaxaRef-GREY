---
title: "Maine_COI_simple"
author: "Erin Grey"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

### DEFINE THE FOLLOWING VARIABLES FOR YOUR ANALYSIS
## locus choices are: 
## (GENES) "ATP6" "ATP8"  "COI"  "COII"  "COIII"  "CYTB"  "ND1"  "ND2"  "ND3"  "ND4" "ND4L" "ND5"  "ND6"  
## (OTHER FEATURES) "rRNA_12S" "rRNA_16S" "D_loop" "tRNA_Ala" "tRNA_Arg" "tRNA_Asn" "tRNA_Asp" "tRNA_Cys" "tRNA_Gln" "tRNA_Glu" "tRNA_Gly" "tRNA_His" "tRNA_Ile" "tRNA_Leu" "tRNA_Lys" "tRNA_Met" "tRNA_Phe" "tRNA_Pro" "tRNA_Ser" "tRNA_Thr" "tRNA_Trp" "tRNA_Tyr" "tRNA_Val"
## species_list must have "search_name" column that has species binomials

```{r define_variables}
######### CHECK/UPDATE ALL OF THESE EACH TImE
entrez_key <- "7c5ac035201a1835b5a81de1b74ec8613d08" #GET YOUR OWN ENTREZ KEY AND PUT IT HERE!
locus = "COI" #name of target locus, see choices above 
species_list_name <- "GNRMaineSpecies_May2024" # name of the species list without the .csv; must be .csv and have column named "species" with binomial
output_folder <- paste(species_list_name, locus, Sys.Date(), sep="-") #name of your output folder every time
species_list <- read.csv(paste("workingfiles/", species_list_name, ".csv", sep=""), header=TRUE) # read in the species list
include_missing_clades <- "yes" # put yes if you want to do this, anything else will be no. If yes, fill out the variables below.
format <- "dada" # dada for the dada2 assignTaxonomy format, anything else will not format past REFDB_uniques
subset_for_testing <- "yes" # put yes if you want to do this, onything else will be no. If yes, fill out the variables below.

### INCLUDE MISSING CLADE SEQUENCES?
if (include_missing_clades == "yes") {
  clade_list <- read.csv("workingfiles/EukaryoteFamilies_NCBI_2023-09-19.csv") # list of eukaryote families in NCBI, change if necessary
  clade_level <- "order" # what taxonomic level do you want representatives for, 
  max_species_per_clade = 3 # how many representative species per missing clade? must be numeric
}

### SUBSET FOR TESTING?
if (subset_for_testing == "yes") {
  species_list <- species_list[sample(nrow(species_list), 10, replace=FALSE),] ## SUBSET FOR TESTING
  clade_list <- clade_list[sample(nrow(clade_list), 10, replace=FALSE),] ## SUBSET FOR TESTING
}
```

### LOAD PACKAGES, FUNCTIONS, KEYS, OUTPUT FOLDER, LOCUS TERMS, FORMAT SPECIES LIST
```{r loadPackagesAndTerms}
source("functions.R") #use these in-house functions in this R script

library(rentrez) #queries ENTREZ databases and downloads accessions
library(AnnotationBustR) #list of locus synonyms
library(reutils) #other packages need it
library(ape) #convert fasta, fastq, etc.
library(data.table) #faster processing
library(Biostrings) #sequence manipulations

set_entrez_key(entrez_key) #set the Entrez API key

dir.create(output_folder) #create the output folder

# Get the locus search term
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
mtDNAterms <- rbind(mtDNAterms, data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA")) # adding other synonyms I've found
is_mtgene <- locus %in% c("ATP6","ATP8","COI","COII","COIII","CYTB","ND1","ND2","ND3","ND4","ND4L","ND5","ND6") #is locus a gene? needed for scraping
locus_synonyms <- mtDNAterms[mtDNAterms$Locus==locus,] #the target locus synonyms
locus_synonyms$Terms <- paste0("OR ", locus_synonyms$Name, "[TITL]") # format for ENTREZ search terms
locus_synonyms$Terms[1] <- paste0("AND (", locus_synonyms$Name[1], "[TITL]") # first term starts with "AND ("
locus_synonyms$Terms[dim(locus_synonyms)[1]] <- paste0("OR ", locus_synonyms$Name[dim(locus_synonyms)[1]], "[TITL])") #last term ends with a ")"
locus_searchterm <- paste(as.vector(locus_synonyms$Terms), collapse=" ") # the big ENTREZ locus search term
print(locus_searchterm)

# Read in the species list and create a taxonomy dataframe
tax_df <- add_taxids_to_taxonomy(species_list)
tax_df <- tax_df[,c("superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species")]
tax_df <- tax_df[tax_df$species != "na",] # remove any taxa without species names
tax_df <- backfill_missing_ranks(tax_df)
head(tax_df) # check format
```

### GET SPECIES REPRESENTATIVES FOR MISSNG CLADES (optional)
```{r getMissingClades_optional}
if (include_missing_clades == "yes") {
  # Identify Clades not represented in the species list
  clades_tax_df <- unique(tax_df[[clade_level]]) 
  setDT(clade_list)
  clade_uniques <- clade_list[!duplicated(clade_list[, ..clade_level]),] # deduplicate the clade of interest in the list
  clades_missing <- clade_uniques[!(get(clade_level) %in% clades_tax_df), .(superkingdom, kingdom, phylum, class, order)] 
  # Find species and locus accessions for missing clades
  clades_missing$spp_list <- NA
  clade_seqs <- process_missing_clades(
    clades_missing = clades_missing,
    locus_searchterm = locus_searchterm,
    rank_column = clade_level,
    max_species_per_clade = max_species_per_clade
  )
}
```

### SEARCH ENTREZ FOR ACCESSIONS BY LOCUS AND SPECIES LIST
```{r search_species_accessions}
setDT(tax_df) # Convert to data.table for faster processing

# Process all species and update data.table by reference
cat("Searching GenBank for", nrow(tax_df), "species\n")

results_list <- lapply(1:nrow(tax_df), function(i) {
  cat("\rFinding GenBank accessions & mitogenomes for species", i, "of", nrow(tax_df))
  
  search_species_accessions(
    species_row = tax_df[i, ],
    locus_searchterm = locus_searchterm,
    delay = 0.35
  )
})

cat("\n")

# Convert results_list to data.frame
results_df <- rbindlist(lapply(results_list, function(x) {
  data.frame(
    n_mitogenome = x$n_mitogenome,
    ids_mitogenome = x$ids_mitogenome,
    n_target = x$n_target,
    ids_target = x$ids_target,
    stringsAsFactors = FALSE
  )
}), fill = TRUE)

# Add the search results to tax_df
tax_df$n_mitogenome <- results_df$n_mitogenome
tax_df$ids_mitogenome <- results_df$ids_mitogenome
tax_df$n_target <- results_df$n_target
tax_df$ids_target <- results_df$ids_target

# Now combine with clade_seqs
setDT(tax_df)
setDT(clade_seqs)
clade_seqs$clade_representative = "yes"
tax_df$clade_representative = "no"
tax_df[, n_mitogenome := as.numeric(n_mitogenome)]
tax_df[, n_target := as.numeric(n_target)]

# Make sure both have the same columns
tax_df <- rbind(tax_df, clade_seqs, fill = TRUE)
setDT(tax_df) # Convert to data.table for faster operations
tax_df[, n_mitogenome := as.numeric(n_mitogenome)] # format
tax_df[, n_target := as.numeric(n_target)] #format

# Save results
fwrite(tax_df, file.path(output_folder, paste0("tax_accessions_", locus, "_", Sys.Date(),".csv")))

cat("Complete! Saved results to tax_accessions.csv\n")

```

### GET ACCESSIONS
```{r fetch_accessions}
cat("Fetching accessions for", nrow(tax_df), "species\n")

results_list <- vector("list", nrow(tax_df))
failed_species <- data.frame(
  species = character(),
  status = character(),
  row_number = integer(),
  stringsAsFactors = FALSE
)

for (i in 1:nrow(tax_df)) {
  cat("\rFetching accessions for species", i, "of", nrow(tax_df))
  
  result <- tryCatch({
    fetch_species_accessions(
      species_row = tax_df[i, ],
      locus = locus,
      output_folder = output_folder,
      max_seqs = 100
    )
  }, error = function(e) {
    warning(paste("\nError processing species", i, ":", e$message))
    species_name <- if (!is.null(tax_df[i, ]$species)) tax_df[i, ]$species else "unknown"
    return(list(data = NULL, status = "error", species = species_name))
  })
  
  # Track failures
  if (!is.null(result$status) && result$status != "success") {
    failed_species <- rbind(failed_species, data.frame(
      species = ifelse(is.null(result$species), "unknown", result$species),
      status = result$status,
      row_number = i,
      stringsAsFactors = FALSE
    ))
  }
  
  # Extract just the data frame part
  results_list[[i]] <- result$data
  
  Sys.sleep(1)
}

cat("\n")

# Combine results - now just data frames
results_list <- results_list[!sapply(results_list, is.null)]

if (length(results_list) == 0) {
  warning("No sequences fetched for any species")
  REFDB_accessions <- data.frame()
} else {
  REFDB_accessions <- do.call(rbind, results_list)
  row.names(REFDB_accessions) <- NULL
  cat("Complete! Fetched", nrow(REFDB_accessions), "sequences\n")
}

# Report failures
if (nrow(failed_species) > 0) {
  cat("\n", nrow(failed_species), "species failed:\n")
  print(failed_species)
  
  # Save failed species list
  write.csv(failed_species, file.path(output_folder, "failed_species.csv"), row.names = FALSE)
  cat("\nFailed species list saved to:", file.path(output_folder, "failed_species.csv"), "\n")
  
  # Summary by failure type
  cat("\nFailure reasons:\n")
  print(table(failed_species$status))
}
```

### GET TARGET LOCI FROM MITOGENOMES
```{r scrape_mitogenomes}
setDT(tax_df) # Convert to data.table for faster operations

REFDB_scrapes <- rbindlist(lapply(1:nrow(tax_df), function(i) {
  cat("\rSpecies", i, "of", nrow(tax_df))
  
  process_species_mitogenomes(
    as.list(tax_df[i, ]), 
    target_synonyms = locus_synonyms$Name,
    is_gene = is_mtgene,
    max_mitos = 20
  )
}), fill = TRUE)

REFDB_scrapes <- REFDB_scrapes[!is.na(sequence)] # Remove rows with NA sequences
cat("\nComplete! Processed", nrow(REFDB_scrapes), "sequences\n")

REFDB_all <- rbind(REFDB_accessions, REFDB_scrapes)
REFDB_all <- merge(REFDB_all, tax_df[,c("superkingdom","kingdom","phylum","class","order","family","genus","species")], by="species", all.x=TRUE)
```

## De-duplicate the reference database, but keep track of duplicates in original species_list
```{r remove_duplicates}

setDT(REFDB_all) # Convert to data.table
REFDB_unique <- REFDB_all[!duplicated(sequence)] # Remove duplicates while keeping first occurrence

# Aggregate duplicates - MUCH faster than looping
duplicate_summary <- REFDB_all[, .(
  duplicate_accessions = paste(seq_accession, collapse = "|"),
  duplicate_species = paste(unique(species), collapse = "|")
), by = sequence]

# Merge back to unique sequences
REFDB_unique <- merge(
  REFDB_unique, 
  duplicate_summary, 
  by = "sequence", 
  all.x = TRUE
)

fwrite(REFDB_unique, file.path(output_folder, paste0("REFDB_unique_", locus, "_", Sys.Date(),".csv"))) # Save results


cat("Saved", nrow(REFDB_unique), "unique sequences\n")

```

## Summarize ref sequence results for species in the original list
```{r summarize_species_list}

setDT(species_list)
setDT(REFDB_unique)

# Format species_list
species_list[, species_id := paste0(matched_name2, "_", taxon_id)]

# Aggregate all information from REFDB_unique in one step
agg_info <- REFDB_unique[, .(
  n_unique_seqs = .N,
  n_target = sum(type == "accession"),
  n_mitogenome = sum(type == "scrape"),
  dup_accessions = paste(unique(unlist(strsplit(paste(duplicate_accessions, collapse = "|"), "\\|"))), collapse = "|"),
  dup_species = {
    all_dup <- unlist(strsplit(paste(duplicate_species, collapse = "|"), "\\|"))
    paste(unique(all_dup), collapse = "|")
  },
  dup_species_n = {
    all_dup <- unlist(strsplit(paste(duplicate_species, collapse = "|"), "\\|"))
    length(unique(all_dup))
  }
), by = species]

# Merge with species_list
species_summary <- merge(species_list, agg_info, 
                        by.x = "species_id", by.y = "species", 
                        all.x = TRUE)

# Handle NAs
species_summary[is.na(n_unique_seqs), n_unique_seqs := 0]
species_summary[is.na(n_target), n_target := 0]
species_summary[is.na(n_mitogenome), n_mitogenome := 0]
species_summary[is.na(dup_accessions), dup_accessions := "na"]
species_summary[is.na(dup_species), dup_species := "na"]
species_summary[is.na(dup_species_n), dup_species_n := 0]

# Calculate total sequences
species_summary[, n_all_seqs := n_mitogenome + n_target]

# Summary stats
n_species_withnames <- nrow(species_summary)
n_species_withNCBInames <-  species_summary[data_source_title == "National Center for Biotechnology Information", .N]
n_species_withNCBInamesANDtargets <- species_summary[data_source_title == "National Center for Biotechnology Information" & n_all_seqs > 0, .N]
n_species_justAccessions <- species_summary[n_target > 0 & n_mitogenome == 0, .N]
n_species_justMitogenomes <- species_summary[n_target == 0 & n_mitogenome > 0, .N]
n_species_bothAccessionsAndMitogenomes <- species_summary[n_target > 0 & n_mitogenome > 0, .N]

# Save results
fwrite(species_summary, file.path(output_folder, paste0("species_list_summary_", locus, "_", Sys.Date(),".csv")))

# Print results
cat("Saved species_list_summary.csv\n")
cat("Species in the list:", n_species_withnames, "\n")
cat("Species with NCBI names:", n_species_withNCBInames, "\n")
cat("Species with NCBI names AND targets:", n_species_withNCBInamesANDtargets, "\n")
cat("Species with only Accessions:", n_species_justAccessions, "\n")
cat("Species with only Mitogenomes:", n_species_justMitogenomes, "\n")
cat("Species with Accessions & Mitogenomes:", n_species_bothAccessionsAndMitogenomes, "\n")
```

## Format REFDB for dada2 assignTaxonomy()
```{r format_dada2_optional}
if (format == "dada") {
  REFDB_unique_dada <- merge(x=REFDB_unique, y=tax_df, by="species", all=TRUE) 
  REFDB_unique_dada <- REFDB_unique_dada[!is.na(REFDB_unique_dada$sequence),]

  # Create header column with ">" at the beginning
  REFDB_unique_dada[, header := paste0(
    ">",
    paste(
      ifelse(is.na(kingdom.x), "", kingdom.x),
      ifelse(is.na(phylum.x), "", phylum.x),
      ifelse(is.na(class.x), "", class.x),
      ifelse(is.na(order.x), "", order.x),
      ifelse(is.na(family.x), "", family.x),
      ifelse(is.na(genus.x), "", genus.x),
      ifelse(is.na(species), "", species),
      sep = ";"
    )
  )]

  REFDB_unique_dada <- REFDB_unique_dada[,c("header","sequence")]
  write.table(REFDB_unique_dada, file.path(output_folder, paste0("REFDB_unique_dada_", locus, "_", Sys.Date(),".fasta")), sep="\n", col.names=FALSE, row.names=FALSE, quote=FALSE)

  cat("Saved dada reference library with", nrow(REFDB_unique_dada), "sequences across", length(unique(REFDB_unique_dada$header)), "species\n")
}
```